---
title: TextArea
description: The TextArea component provides a multi-line text input field with labels, validation, error states, and responsive floating label behavior. It supports customizable rows, resize options, and comprehensive form integration.
category: components
tags:
    - textarea
    - component
    - input
    - multiline
    - form
    - textfield
    - description
    - comment
    - message
    - content
RepoFolderName: TextArea
StorybookLink: components-textarea--docs
---

<TextareaPreview />

## Usage

```tsx
import { TextArea } from '@juspay/blend-design-system'

function MyComponent() {
    const [description, setDescription] = useState('')

    const handleDescriptionChange = (
        e: React.ChangeEvent<HTMLTextAreaElement>
    ) => {
        setDescription(e.target.value)
    }

    return (
        <TextArea
            label="Description"
            placeholder="Enter your description..."
            value={description}
            onChange={handleDescriptionChange}
            rows={4}
            hintText="Provide a detailed description"
            required
        />
    )
}
```

## API Reference

<DocsTypeTable
    data={[
        [
            {
                content: 'value',
                hintText: 'Current textarea value as a string',
            },
            { content: 'string', hintText: 'string' },
            { content: '' },
        ],
        [
            {
                content: 'placeholder',
                hintText: 'Placeholder text for the textarea',
            },
            { content: 'string', hintText: 'string' },
            { content: '' },
        ],
        [
            {
                content: 'onChange',
                hintText: 'Callback when textarea value changes',
            },
            {
                content: '(e: React.ChangeEvent<HTMLTextAreaElement>) => void',
                hintText: 'function',
            },
            { content: '' },
        ],
        [
            {
                content: 'disabled',
                hintText: 'Whether the textarea is disabled',
            },
            { content: 'boolean', hintText: 'boolean' },
            { content: 'false' },
        ],
        [
            {
                content: 'autoFocus',
                hintText: 'Whether to auto-focus the textarea on mount',
            },
            { content: 'boolean', hintText: 'boolean' },
            { content: 'false' },
        ],
        [
            {
                content: 'onFocus',
                hintText: 'Callback when textarea receives focus',
            },
            {
                content: '(e: React.FocusEvent<HTMLTextAreaElement>) => void',
                hintText: 'function',
            },
            { content: '' },
        ],
        [
            {
                content: 'onBlur',
                hintText: 'Callback when textarea loses focus',
            },
            {
                content: '(e: React.FocusEvent<HTMLTextAreaElement>) => void',
                hintText: 'function',
            },
            { content: '' },
        ],
        [
            {
                content: 'rows',
                hintText: 'Number of visible text lines',
            },
            { content: 'number', hintText: 'number' },
            { content: '3' },
        ],
        [
            {
                content: 'cols',
                hintText: 'Number of visible character columns',
            },
            { content: 'number', hintText: 'number' },
            { content: '' },
        ],
        [
            {
                content: 'label',
                hintText: 'Primary label for the textarea',
            },
            { content: 'string', hintText: 'string' },
            { content: '' },
        ],
        [
            {
                content: 'sublabel',
                hintText: 'Secondary label or description',
            },
            { content: 'string', hintText: 'string' },
            { content: '' },
        ],
        [
            {
                content: 'hintText',
                hintText: 'Helper text displayed below the textarea',
            },
            { content: 'string', hintText: 'string' },
            { content: '' },
        ],
        [
            {
                content: 'helpIconHintText',
                hintText: 'Tooltip text for the help icon',
            },
            { content: 'string', hintText: 'string' },
            { content: '' },
        ],
        [
            {
                content: 'required',
                hintText: 'Whether the textarea is required',
            },
            { content: 'boolean', hintText: 'boolean' },
            { content: 'false' },
        ],
        [
            {
                content: 'error',
                hintText: 'Whether the textarea is in error state',
            },
            { content: 'boolean', hintText: 'boolean' },
            { content: 'false' },
        ],
        [
            {
                content: 'errorMessage',
                hintText: 'Error message to display when in error state',
            },
            { content: 'string', hintText: 'string' },
            { content: '' },
        ],
        [
            {
                content: 'resize',
                hintText: 'Resize behavior for the textarea',
            },
            {
                content:
                    "'none' | 'both' | 'horizontal' | 'vertical' | 'block' | 'inline'",
                hintText: 'string',
            },
            { content: "'none'" },
        ],
        [
            {
                content: 'wrap',
                hintText: 'Text wrapping behavior',
            },
            { content: "CSSObject['whiteSpace']", hintText: 'string' },
            { content: '' },
        ],
    ]}
    className="mb-8"
    emptyMessage="No props available"
    loadingMessage="Loading props..."
/>

## Component Tokens

You can style the TextArea component using the following tokens:

```tsx
export type TextAreaTokensType = {
    fontFamily: CSSObject['fontFamily']
    paddingX: CSSObject['padding']
    paddingY: CSSObject['padding']
    borderRadius: CSSObject['borderRadius']
    boxShadow: {
        [key in TextAreaState]: CSSObject['boxShadow']
    }
    outline: {
        [key in TextAreaState]: CSSObject['outline']
    }
    border: {
        [key in TextAreaState]: CSSObject['border']
    }
    color: {
        [key in TextAreaState]: CSSObject['color']
    }
    backgroundColor: {
        [key in TextAreaState]: CSSObject['backgroundColor']
    }
}

export type ResponsiveTextAreaTokens = {
    [key in keyof BreakpointType]: TextAreaTokensType
}

export type TextAreaState = 'default' | 'hover' | 'focus' | 'error' | 'disabled'
```

The component uses responsive tokens that adapt to different breakpoints with floating labels on small screens and consistent styling across all states.

## Features

- **Multi-line Input**: Configurable rows and columns for text area sizing
- **Responsive Labels**: Floating labels on small screens, standard labels on larger screens
- **Resize Control**: Customizable resize behavior (none, vertical, horizontal, both)
- **Error States**: Visual error feedback with custom error messages
- **Form Integration**: Full form library support with validation
- **Accessibility**: Screen reader support and proper focus management
- **Helper Text**: Support for hint text and help icon tooltips
- **Character Counting**: Can be extended with character count functionality
- **Auto-Focus**: Optional auto-focus on component mount
- **Disabled State**: Complete disabled state styling and behavior

## Usage Examples

### Basic Description Field

Simple textarea for user descriptions:

```tsx
import { TextArea } from '@juspay/blend-design-system'

const [description, setDescription] = useState('')

const handleDescriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setDescription(e.target.value)
}

;<TextArea
    label="Description"
    placeholder="Tell us about yourself..."
    value={description}
    onChange={handleDescriptionChange}
    rows={4}
    hintText="Share your background and experience"
/>
```

### Comment Box

Textarea for user comments with validation:

```tsx
const [comment, setComment] = useState('')
const [isInvalid, setIsInvalid] = useState(false)

const validateComment = (value: string) => {
    if (value.length > 500) {
        setIsInvalid(true)
        return false
    }
    setIsInvalid(false)
    return true
}

const handleCommentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const value = e.target.value
    setComment(value)
    validateComment(value)
}

;<TextArea
    label="Comment"
    sublabel="Share your thoughts"
    placeholder="Write your comment here..."
    value={comment}
    onChange={handleCommentChange}
    rows={3}
    error={isInvalid}
    errorMessage="Comment must be 500 characters or less"
    hintText={`${comment.length}/500 characters`}
    required
/>
```

### Feedback Form

Large textarea for detailed feedback:

```tsx
const [feedback, setFeedback] = useState('')

const handleFeedbackChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setFeedback(e.target.value)
}

;<TextArea
    label="Detailed Feedback"
    sublabel="Help us improve our service"
    placeholder="Please provide detailed feedback about your experience..."
    value={feedback}
    onChange={handleFeedbackChange}
    rows={6}
    resize="vertical"
    hintText="Your feedback is valuable to us"
    helpIconHintText="This information helps us understand your needs better"
/>
```

### Message Composer

Resizable textarea for message composition:

```tsx
const [message, setMessage] = useState('')
const [isDraft, setIsDraft] = useState(false)

const handleMessageChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setMessage(e.target.value)
    setIsDraft(true)

    // Auto-save draft
    setTimeout(() => {
        localStorage.setItem('messageDraft', e.target.value)
    }, 500)
}

const sendMessage = () => {
    if (message.trim()) {
        // Send message logic
        setMessage('')
        setIsDraft(false)
        localStorage.removeItem('messageDraft')
    }
}

;<div>
    <TextArea
        label="Message"
        placeholder="Type your message..."
        value={message}
        onChange={handleMessageChange}
        rows={4}
        resize="both"
        hintText={isDraft ? 'Draft saved' : 'Start typing your message'}
        autoFocus
    />
    <button
        onClick={sendMessage}
        disabled={!message.trim()}
        style={{ marginTop: '8px' }}
    >
        Send Message
    </button>
</div>
```

### Code Snippet Input

Textarea for code or technical content:

```tsx
const [codeSnippet, setCodeSnippet] = useState('')

const handleCodeChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setCodeSnippet(e.target.value)
}

;<TextArea
    label="Code Snippet"
    sublabel="Paste your code here"
    placeholder="// Enter your code here..."
    value={codeSnippet}
    onChange={handleCodeChange}
    rows={8}
    resize="vertical"
    wrap="off"
    hintText="Supports all programming languages"
    style={{ fontFamily: 'monospace' }}
/>
```

### Article Content

Large textarea for article or blog content:

```tsx
const [articleContent, setArticleContent] = useState('')
const [wordCount, setWordCount] = useState(0)

const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const content = e.target.value
    setArticleContent(content)

    // Calculate word count
    const words = content.trim() ? content.trim().split(/\s+/).length : 0
    setWordCount(words)
}

;<TextArea
    label="Article Content"
    sublabel="Write your article"
    placeholder="Start writing your article..."
    value={articleContent}
    onChange={handleContentChange}
    rows={12}
    resize="vertical"
    hintText={`Word count: ${wordCount} ${wordCount === 1 ? 'word' : 'words'}`}
    helpIconHintText="Write engaging content for your readers"
/>
```

### Support Ticket

Textarea for customer support requests:

```tsx
const [issueDescription, setIssueDescription] = useState('')
const [priority, setPriority] = useState('medium')

const handleIssueChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setIssueDescription(e.target.value)
}

;<div>
    <select
        value={priority}
        onChange={(e) => setPriority(e.target.value)}
        style={{ marginBottom: '16px' }}
    >
        <option value="low">Low Priority</option>
        <option value="medium">Medium Priority</option>
        <option value="high">High Priority</option>
    </select>

    <TextArea
        label="Issue Description"
        sublabel={`Priority: ${priority.charAt(0).toUpperCase() + priority.slice(1)}`}
        placeholder="Describe the issue you're experiencing..."
        value={issueDescription}
        onChange={handleIssueChange}
        rows={5}
        resize="vertical"
        required
        hintText="Include steps to reproduce the issue if applicable"
        helpIconHintText="Detailed descriptions help us resolve issues faster"
    />
</div>
```

## Behavior

### Responsive Labels

- **Large Screens**: Labels appear above the textarea with sublabels
- **Small Screens**: Labels float inside the textarea and scale when focused or filled
- **Focus Animation**: Smooth transition for floating label positioning
- **Label Scaling**: Floating labels scale down when active

### Resize Functionality

- **None**: No resize handle, fixed size
- **Vertical**: Only vertical resizing allowed
- **Horizontal**: Only horizontal resizing allowed
- **Both**: Both directions resizable
- **Block/Inline**: CSS logical properties for resize direction

### Focus and Validation

- **Focus States**: Visual focus indicators with border and shadow changes
- **Error States**: Red borders and error message display
- **Validation**: Real-time validation support with error feedback
- **Required Fields**: Visual indicators for required fields

### Padding Adjustments

- **Dynamic Padding**: Adjusts top/bottom padding on small screens for floating labels
- **Consistent Spacing**: Maintains consistent internal spacing across breakpoints
- **Content Alignment**: Proper text alignment with floating label positioning

## Best Practices

### When to Use TextArea

- **Long-form Content**: Comments, descriptions, articles, messages
- **Multi-line Input**: Address fields, feedback forms, code snippets
- **Flexible Content**: When content length is unpredictable
- **Rich Text Needs**: Before implementing rich text editors
- **Form Fields**: Any form requiring more than a single line of text

### Sizing Guidelines

- **3-4 Rows**: Short descriptions, comments, brief feedback
- **5-6 Rows**: Medium content like detailed descriptions, messages
- **8+ Rows**: Long-form content like articles, documentation
- **Resize Options**: Allow vertical resize for user flexibility
- **Character Limits**: Implement and display character count when needed

### Accessibility Considerations

- **Label Association**: Ensure proper label-textarea association
- **Error Announcements**: Make error states accessible to screen readers
- **Focus Management**: Maintain clear focus indicators
- **Keyboard Navigation**: Support all standard keyboard interactions
- **Help Text**: Provide clear instructions and help text

### Form Integration

- **Controlled Components**: Always use controlled components with proper state
- **Validation**: Integrate with form validation libraries
- **Error Handling**: Provide specific, actionable error messages
- **Auto-save**: Consider implementing draft saving for long forms
- **Character Counting**: Show character/word count for length-limited fields

### Performance Optimization

- **Debouncing**: Debounce onChange for expensive operations
- **Auto-save**: Implement debounced auto-save for long content
- **Memory Management**: Clean up event listeners and timers
- **State Management**: Use appropriate state management patterns
- **Memoization**: Consider memoizing for complex validation logic

### User Experience

- **Clear Placeholders**: Use descriptive placeholder text
- **Progressive Enhancement**: Start with basic functionality
- **Auto-resize**: Consider auto-expanding textarea based on content
- **Save Indicators**: Show save status for important content
- **Format Preservation**: Maintain formatting when appropriate

### Content Guidelines

- **Character Limits**: Set reasonable limits and communicate them clearly
- **Validation Messages**: Provide helpful, specific error messages
- **Formatting Support**: Consider markdown or rich text for complex content
- **Preview Options**: Offer preview functionality for formatted content
- **Content Recovery**: Implement draft recovery for important forms

### Security Considerations

- **Input Sanitization**: Sanitize user input on the backend
- **XSS Prevention**: Prevent cross-site scripting attacks
- **Content Validation**: Validate content length and format
- **Rate Limiting**: Implement rate limiting for form submissions
- **CSRF Protection**: Use CSRF tokens for form submissions
